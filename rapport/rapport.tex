\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{float}

\geometry{a4paper,total={170mm,257mm},left=20mm,top=20mm,}

\title{Polyomino tiling and exact cover}
\author{Thomas Cambier\\Thibault Dardinier}

\parskip=0.8em

\newcommand{\foreign}{\textit}
\newcommand{\illustration}[2]{
	\begin{figure}[]
	\begin{center}
	\includegraphics[width=0.9\textwidth]{images/#1.png}
	\caption{#2}
	\label{fig:#1}
	\end{center}
	\end{figure}
}

\renewcommand{\thesection}{\Roman{section}}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\section{Polyominoes}

\subsection{The Square class}

In order to efficiently represent and manipulate polyominoes, which are represented as a set of squares, we needed an efficient representation of those squares.
A square has unsurprisingly two main attributes, $(int) x$ and $(int) y$.
It also has a third attribute, $(Color) color$, which is only used to efficiently draw polyominoes.

In order to be able to use efficient data structures such as sets for polyominoes, we overrode $equals$ and $hashCode$\footnote{The hashcode we implemented is not really efficient, because it returns 1 everytime.
We had an issue with another hashcode method we previously implemented, two polyominoes with the same set of squares could be in a set.
It is of course possible, with more time, to handle this issue by understanding where in our code we change a square when it is already in a polyomino which is itself in a set.}
 methods: two squares are equal if and only if their coordinates are the same.
We also have generic methods we will discuss when talking about generating symmmetrical
and rotationnal polyominoes.

Eventually, we have methods to manipulate squares of polyominoes, such as translations of squares, dilatation of one square (ie. translation), reflections, rotations...
These methods don’t make sense for a square alone, but they make sense when thinking about a polyomino.
We use squares as squares, of course, but also as vectors (of translation for instance), and even for storing data such as dimensions (width and height).


\subsection{The Polyomino class}

A polyomino is represented by a set of squares, which is his main attribute.
As well as for the Square class, we had to override $equals$ and $hashCode$: two polyominoes are equal if and only if their squares are the same, the hashCode is the hashCode of the set\footnote{Since the hashCode of a set if the sum of the hashCodes of his elements, it is in our case the size of the set.}.

There are a lot of methods for manipulating polyominoes, such as translation, dilatation, $\frac{\pi}{2}$ rotation... which are related to the ones previously defined for the squares.
We can also create an empty polyomino, or create a polyomino from a $String$.
We can check whether a polyomino is included in another one, whether a polyomino is a polyomino (\foreign{ie.} its squares are connected).

\subsection{Manipulate polyominoes}

The Manipulate class contains the useful functions for creating polyominoes from a file, drawing a list of polyominoes side by side (on figure \ref{fig:INF421} for instance), or drawing the polyominoes with their given coordinates, to see solutions of tiling problems.

\illustration{INF421}{Six random polyominoes with random colors, side to side.}

It also contains the functions we created to generate fixed and free polyminoes in a given rectangle, Redelmeier's function to generate fixed polyominoes of a given size, and a bunch of functions to generate symmetrical and rotational polyominoes.



\section{Generating polyominoes}

\subsection{A naive generator for fixed and free polyominoes}

To generate all the fixed polyminoes in a given area, we simply proceed in a few simple steps.
First of all, we generate every possible combination of squares in the given area: for each square in the area, we add it or not to the already existing set of squares.
We then have to check for every of these combinations if it's connected\footnote{We use a simple BFS to check if the squares are connected}, and if it is, we put it in canonical form\footnote{We simply put it at most up and left.}, and add it to a set\footnote{Thanks to the $equal$ and $hashCode$ methods we overrode.}
At the end of this algorithm, we get all the different fixed polyominoes in the given area.

\illustration{free_3_3}{All free polyominoes contained in a square of size 3.}

To compute all the free polyominoes with the same constraint (as we can see on figure \ref{fig:free_3_3}), we firstly compute the previous function with the same area.
Then, we use a set, and for every polyomino we get, we generate his four rotations, and his four rotations after a symetry.
If one of his form is in the set, we don't add it, otherwise we add it.

\subsection{Generating fixed polyominoes with Redelmeier’s method}



\subsection{Generating symmetrical and rotational polyominoes}

\illustration{diagonal}{All free polyominoes stable by reflection in descending diagonal, sized under 12.}

We do not compute all types of symmetrical polyminoes.
We compute 

\illustration{rotational_25}{All free polyominoes stable by $\frac{\pi}{2}$ rotation, sized under 25.}



\section{Exact cover and tiling}

\subsection{Exact cover and the dancing links algorithm}

\subsection{From the polyomino tiling problem to exact cover}

\end{document}
