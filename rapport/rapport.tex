\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{float}

\geometry{a4paper,total={170mm,257mm},left=20mm,top=20mm,}

\title{Polyomino tiling and exact cover}
\author{Thomas Cambier\\Thibault Dardinier}

\parskip=0.8em

\newcommand{\foreign}{\textit}
\newcommand{\illustration}[2]{
	\begin{figure}[]
	\begin{center}
	\includegraphics[width=0.9\textwidth]{images/#1.png}
	\caption{#2}
	\label{fig:#1}
	\end{center}
	\end{figure}
}

\renewcommand{\thesection}{\Roman{section}}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\section{Polyominoes}

\subsection{The Square class}

In order to efficiently represent and manipulate polyominoes, which are represented as a set of squares, we needed an efficient representation of those squares.
A square has unsurprisingly two main attributes, $(int) x$ and $(int) y$.
It also has a third attribute, $(Color) color$, which is only used to efficiently draw polyominoes.

In order to be able to use efficient data structures such as sets for polyominoes, we overrode $equals$ and $hashCode$\footnote{The hashcode we implemented is not really efficient, because it returns 1 everytime.
We had an issue with another hashcode method we previously implemented, two polyominoes with the same set of squares could be in a set.
It is of course possible, with more time, to handle this issue by understanding where in our code we change a square when it is already in a polyomino which is itself in a set.}
 methods: two squares are equal if and only if their coordinates are the same.
We also have generic methods we will discuss when talking about generating symmmetrical
and rotationnal polyominoes.

Eventually, we have methods to manipulate squares of polyominoes, such as translations of squares, dilatation of one square (ie. translation), reflections, rotations...
These methods don’t make sense for a square alone, but they make sense when thinking about a polyomino.
We use squares as squares, of course, but also as vectors (of translation for instance), and even for storing data such as dimensions (width and height).


\subsection{The Polyomino class}

A polyomino is represented by a set of squares, which is his main attribute.
As well as for the Square class, we had to override $equals$ and $hashCode$: two polyominoes are equal if and only if their squares are the same, the hashCode is the hashCode of the set\footnote{Since the hashCode of a set if the sum of the hashCodes of his elements, it is in our case the size of the set.}.

There are a lot of methods for manipulating polyominoes, such as translation, dilatation, $\frac{\pi}{2}$ rotation... which are related to the ones previously defined for the squares.
We can also create an empty polyomino, or create a polyomino from a $String$.
We can check whether a polyomino is included in another one, whether a polyomino is a polyomino (\foreign{ie.} its squares are connected).

\subsection{Manipulate polyominoes}

The Manipulate class contains the useful functions for creating polyominoes from a file, drawing a list of polyominoes side by side (on figure \ref{fig:INF421} for instance), or drawing the polyominoes with their given coordinates, to see solutions of tiling problems.

\illustration{INF421}{Six random polyominoes with random colors, side to side.}

It also contains the functions we created to generate fixed and free polyminoes in a given rectangle, Redelmeier's function to generate fixed polyominoes of a given size, and a bunch of functions to generate symmetrical and rotational polyominoes.



\section{Generating polyominoes}

\subsection{A naive generator for fixed and free polyominoes}

To generate all the fixed polyminoes in a given area, we simply proceed in a few simple steps.
First of all, we generate every possible combination of squares in the given area: for each square in the area, we add it or not to the already existing set of squares.
We then have to check for every of these combinations if it is connected\footnote{We use a simple BFS to check if the squares are connected}, and if it is, we put it in canonical form\footnote{We simply put it at most up and left.}, and add it to a set\footnote{Thanks to the $equal$ and $hashCode$ methods we overrode.}.
At the end of this algorithm, we get all the different fixed polyominoes in the given area.

\illustration{free_3_3}{All free polyominoes contained in a square of size 3.}

To compute all the free polyominoes with the same constraint (as we can see on figure \ref{fig:free_3_3}), we first compute the previous function with the same area.
Then, we use a set, and for every polyomino we get, we generate its four rotations, and its four rotations after a symmetry.
If one of its form is in the set, we do not add it, otherwise we add it.

\subsection{Generating fixed polyominoes with Redelmeier’s method}



\subsection{Generating symmetrical and rotational polyominoes}

\illustration{diagonal}{All free polyominoes stable by reflection in descending diagonal, sized under 12.}

We do not compute all types of symmetrical polyominoes.
We compute polyominoes symmetrical with regard to the horizontal axis, the vertical axis, the ascending and descending diagonal, and the ones symmetrical with regard to a point.
Symmetrical polyominoes with regard to the vertical axis (and when the axis is between squares), and with regard to the horizontal axis (when the axis is between squares), that is to say HX and VX polyominoes, are computed using fixed polyominoes of half size.
All the other symmetrical and rotational polyominoes, and fixed polyominoes are all generated using the same generic function.
We only have, for each configuration, to give methods to generate images of the point (none for fixed, three for $\frac{\pi}{2}$ rotations, and one for the others), and a method to know whether a point is allowed or not in the canonical form.
These methods are implemented in the Square interface.

\illustration{rotational_25}{All free polyominoes stable by $\frac{\pi}{2}$ rotation, sized under 25.}



\section{Exact cover and tiling}

\subsection{Exact cover and the dancing links algorithm}

We started to solve the exact cover problem by randomly choosing the first element to cover. Then, we limited the number of reachable possibilities at every step by carefully choosing the first element to cover\footnote{We choose the first element such that the number of subsets containing this element is minimal} which sped up the algorithm. At first we were returning all the covers found by the algorithm even though some of them were not exact covers. To improve that, we checked the exactness of every cover returned and finally chose to stop at the first exact cover met for efficiency reasons. The class ExactCover also contains useful functions to manipulate matrices. 

However this algorithm was still far too slow for solving exact cover problems, hence we implemented the dancing links structure. This structure allowed us to solve larger instances of the exact cover problem. As well as for the first algorithm, we chose to stop once a solution is found to improve the efficiency.



\subsection{From the polyomino tiling problem to exact cover}


\end{document}
